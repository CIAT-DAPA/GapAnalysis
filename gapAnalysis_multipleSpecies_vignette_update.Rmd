---
title: "Gap Analysis Workflow for Multiple Species"
output: 
  html_document:
    css: styles.css
vignette: >
  %\VignetteIndexEntry{Gap Analysis Workflow for Multiple Species}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 12, fig.height = 6)
```

## Introduction

This vignette outlines a reproducible workflow for conducting gap analysis for multiple species using spatial data, SDMs, and environmental layers.  
We demonstrate three different methods for processing and storing results for multiple species:
1. Using a named list and for-loop (classic approach)
2. Using conditional binding to a data frame (row-binding approach)
3. Using functional programming with `{purrr}` (functional approach)

All methods use the same general workflow:
- Calculate SRSex
- Four check functions
- Main gap analysis steps

---

## Data Preparation

```{r}
# Load packages
pacman::p_load(dplyr, terra, sf, leaflet, purrr)

# Source R functions
files <- list.files("R", pattern = "\\.[rR]$", full.names = TRUE)
for (f in files) source(f)

# Load data
load("data/CucurbitaData.rda")      # Occurrence data
load("data/CucurbitaRasts.rda")     # Raster list
load("data/protectAreasRast.rda")   # Protected areas raster
load("data/ecoExample.rda")         # Ecoregions data

# Prepare ecoregion and protected area layers
ecos <- terra::vect(eco1)
proAreas <- terra::unwrap(protectAreasRast)

# Standardize the CRS across all spatial layers to prevent mismatch warnings
target_crs <- "+proj=longlat +datum=WGS84"
ecos <- terra::project(ecos, target_crs)
proAreas <- terra::project(proAreas, target_crs)

# Get unique species names and SDM rasters as a list
taxa <- unique(CucurbitaData$species)
sdms <- terra::unwrap(CucurbitaRasts)
sdmList <- lapply(seq_along(taxa), function(i) {
  r <- sdms[[i]]
  # Compare CRS as character strings
  if (terra::crs(r, proj=TRUE) != terra::crs(ecos, proj=TRUE)) {
    r <- terra::project(r, terra::crs(ecos))
  }
  # Convert 0 to NA, keeping only 1 and NA in the dataset
  r <- terra::subst(r, 0, NA)
  r[!(is.na(r) | r == 1)] <- NA
  r
})
names(sdmList) <- taxa
```

---

## Example 1: Using a Named List and for-loop

```{r}
results_list <- list()

for (i in seq_along(taxa)) {
  taxon <- taxa[i]
  occurrence_Data <- CucurbitaData[CucurbitaData$species == taxon, ]
  sdm <- sdms[[i]]
  if (terra::crs(sdm, proj=TRUE) != terra::crs(ecos, proj=TRUE)) {
    sdm <- terra::project(sdm, terra::crs(ecos))
  }
  sdm <- terra::subst(sdm, 0, NA)
  sdm[!(is.na(sdm) | sdm == 1)] <- NA

  # 1. Run SRSex first (on all records)
  srsex <- SRSex(taxon = taxon, occurrence_Data = occurrence_Data)

  # 2. Run check functions on inputs
  occurrences <- checkOccurrences(csv = occurrence_Data, taxon = taxon)

  # note: verify sdm is a SpatRaster before proceeding, otherwise skip or check
  if (!inherits(sdm, "SpatRaster")) stop("sdm is not a SpatRaster")

  sdm_checked <- checkRaster(sdm)
  proArea_checked <- checkProtectAreas(proArea = proAreas, sdm = sdm_checked)
  eco_checked <- checkEcoregion(eco = ecos, sdm = sdm_checked, uniqueID = "ECO_ID_U")

  # ---- PLOT: For each species, plot the SDM and the ecoregion overlay, combined ----
  plot(sdm_checked, main = paste(taxon, "- SDM (yellow) and Ecoregions (light blue outline)"))
  plot(ecos, add = TRUE, border = "lightblue", lwd = 2)

  # 3. Continue with main gap analysis
  gBuffer <- generateGBuffers(taxon = taxon,
                              occurrence_Data = occurrences$data,
                              bufferDistM = 50000)

  # Ex-situ analysis
  grsex <- GRSex(taxon = taxon,
                 sdm = sdm_checked,
                 gBuffer = gBuffer$data)
  ersex <- ERSex(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 gBuffer = gBuffer$data,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsex <- FCSex(taxon = taxon,
                 srsex = srsex,
                 grsex = grsex,
                 ersex = ersex)

  # In-situ analysis
  srsin <- SRSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas)
  grsin <- GRSin(taxon = taxon,
                 sdm = sdm_checked,
                 protectedAreas = proAreas)
  ersin <- ERSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsin <- FCSin(taxon = taxon,
                 srsin = srsin,
                 grsin = grsin,
                 ersin = ersin)

  # Final combined FCS score
  fcsmean <- FCSc_mean(taxon = taxon,
                       fcsin = fcsin,
                       fcsex = fcsex)

  # Store results for this taxon in the named list
  results_list[[taxon]] <- list(
    srsex = srsex,
    occurrences = occurrences,
    sdm_checked = sdm_checked,
    proArea_checked = proArea_checked,
    eco_checked = eco_checked,
    grsex = grsex,
    ersex = ersex,
    fcsex = fcsex,
    srsin = srsin,
    grsin = grsin,
    ersin = ersin,
    fcsin = fcsin,
    fcsmean = fcsmean
  )
}
```

---

## Example 2: Using Conditional Binding (Row-binding) and for-loop

```{r, echo=TRUE, eval=FALSE}
results_df <- NULL

for (i in seq_along(taxa)) {
  taxon <- taxa[i]
  occurrence_Data <- CucurbitaData[CucurbitaData$species == taxon, ]
  sdm <- sdms[[i]]
  if (terra::crs(sdm, proj=TRUE) != terra::crs(ecos, proj=TRUE)) {
    sdm <- terra::project(sdm, terra::crs(ecos))
  }
  sdm <- terra::subst(sdm, 0, NA)
  sdm[!(is.na(sdm) | sdm == 1)] <- NA

  if (!inherits(sdm, "SpatRaster")) stop("sdm is not a SpatRaster")

  srsex <- SRSex(taxon = taxon, occurrence_Data = occurrence_Data)
  occurrences <- checkOccurrences(csv = occurrence_Data, taxon = taxon)
  sdm_checked <- checkRaster(sdm)
  proArea_checked <- checkProtectAreas(proArea = proAreas, sdm = sdm_checked)
  eco_checked <- checkEcoregion(eco = ecos, sdm = sdm_checked, uniqueID = "ECO_ID_U")

  # ---- PLOT: Not shown for Example 2 ----
  # plot(sdm_checked, main = paste(taxon, "- SDM (yellow) and Ecoregions (light blue outline)"))
  # plot(ecos, add = TRUE, border = "lightblue", lwd = 2)

  gBuffer <- generateGBuffers(taxon = taxon,
                              occurrence_Data = occurrences$data,
                              bufferDistM = 50000)
  grsex <- GRSex(taxon = taxon,
                 sdm = sdm_checked,
                 gBuffer = gBuffer$data)
  ersex <- ERSex(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 gBuffer = gBuffer$data,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsex <- FCSex(taxon = taxon,
                 srsex = srsex,
                 grsex = grsex,
                 ersex = ersex)
  srsin <- SRSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas)
  grsin <- GRSin(taxon = taxon,
                 sdm = sdm_checked,
                 protectedAreas = proAreas)
  ersin <- ERSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsin <- FCSin(taxon = taxon,
                 srsin = srsin,
                 grsin = grsin,
                 ersin = ersin)
  fcsmean <- FCSc_mean(taxon = taxon,
                       fcsin = fcsin,
                       fcsex = fcsex)

  row <- data.frame(
    taxon = taxon,
    srsex = I(list(srsex)),
    occurrences = I(list(occurrences)),
    sdm_checked = I(list(sdm_checked)),
    proArea_checked = I(list(proArea_checked)),
    eco_checked = I(list(eco_checked)),
    grsex = I(list(grsex)),
    ersex = I(list(ersex)),
    fcsex = I(list(fcsex)),
    srsin = I(list(srsin)),
    grsin = I(list(grsin)),
    ersin = I(list(ersin)),
    fcsin = I(list(fcsin)),
    fcsmean = I(list(fcsmean))
  )

  if (is.null(results_df)) {
    results_df <- row
  } else {
    results_df <- bind_rows(results_df, row)
  }
}
```

---

## Example 3: Functional Programming with `{purrr}`

```{r, echo=TRUE, eval=FALSE}
gap_analysis_workflow <- function(taxon, sdm) {
  occurrence_Data <- CucurbitaData[CucurbitaData$species == taxon, ]
  if (terra::crs(sdm, proj=TRUE) != terra::crs(ecos, proj=TRUE)) {
    sdm <- terra::project(sdm, terra::crs(ecos))
  }
  sdm <- terra::subst(sdm, 0, NA)
  sdm[!(is.na(sdm) | sdm == 1)] <- NA
  if (!inherits(sdm, "SpatRaster")) stop("sdm is not a SpatRaster")
  srsex <- SRSex(taxon = taxon, occurrence_Data = occurrence_Data)
  occurrences <- checkOccurrences(csv = occurrence_Data, taxon = taxon)
  sdm_checked <- checkRaster(sdm)
  proArea_checked <- checkProtectAreas(proArea = proAreas, sdm = sdm_checked)
  eco_checked <- checkEcoregion(eco = ecos, sdm = sdm_checked, uniqueID = "ECO_ID_U")

  # ---- PLOT: Not shown for Example 3 ----
  # plot(sdm_checked, main = paste(taxon, "- SDM (yellow) and Ecoregions (light blue outline)"))
  # plot(ecos, add = TRUE, border = "lightblue", lwd = 2)

  gBuffer <- generateGBuffers(taxon = taxon,
                              occurrence_Data = occurrences$data,
                              bufferDistM = 50000)
  grsex <- GRSex(taxon = taxon,
                 sdm = sdm_checked,
                 gBuffer = gBuffer$data)
  ersex <- ERSex(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 gBuffer = gBuffer$data,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsex <- FCSex(taxon = taxon,
                 srsex = srsex,
                 grsex = grsex,
                 ersex = ersex)
  srsin <- SRSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas)
  grsin <- GRSin(taxon = taxon,
                 sdm = sdm_checked,
                 protectedAreas = proAreas)
  ersin <- ERSin(taxon = taxon,
                 sdm = sdm_checked,
                 occurrence_Data = occurrences$data,
                 protectedAreas = proAreas,
                 ecoregions = ecos,
                 idColumn = "ECO_ID_U")
  fcsin <- FCSin(taxon = taxon,
                 srsin = srsin,
                 grsin = grsin,
                 ersin = ersin)
  fcsmean <- FCSc_mean(taxon = taxon,
                       fcsin = fcsin,
                       fcsex = fcsex)
  list(
    taxon = taxon,
    srsex = srsex,
    occurrences = occurrences,
    sdm_checked = sdm_checked,
    proArea_checked = proArea_checked,
    eco_checked = eco_checked,
    grsex = grsex,
    ersex = ersex,
    fcsex = fcsex,
    srsin = srsin,
    grsin = grsin,
    ersin = ersin,
    fcsin = fcsin,
    fcsmean = fcsmean
  )
}

results_purrr <- purrr::map2(taxa, sdmList, gap_analysis_workflow)
names(results_purrr) <- taxa
```

## Closing Remarks

By running **SRSex first, then input checks, and then the main analyses** for each species, this workflow produces valid, consistent, and reproducible gap analysis results across multiple taxa.  
The three methods outlined above offer adaptable solutions for managing and utilizing results, tailored to your specific workflow requirements.
